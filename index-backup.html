<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Valentine?</title>
  <style>
    :root { --bg1:#0b1020; --bg2:#1a1033; --card:#101a2e; --text:#f4f4ff; --muted:#b9b9d8; }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 800px at 20% 10%, #2b1a5a 0%, transparent 55%),
                  radial-gradient(900px 600px at 80% 30%, #7b1b4a 0%, transparent 55%),
                  linear-gradient(160deg, var(--bg1), var(--bg2));
      color:var(--text);
      overflow:hidden;
    }
    .hearts{
      position:fixed; inset:0; pointer-events:none; opacity:.35;
      background-image:
        radial-gradient(circle at 10% 20%, rgba(255,105,180,.35) 0 2px, transparent 3px),
        radial-gradient(circle at 40% 70%, rgba(255,105,180,.25) 0 2px, transparent 3px),
        radial-gradient(circle at 80% 30%, rgba(255,105,180,.25) 0 2px, transparent 3px),
        radial-gradient(circle at 70% 85%, rgba(255,105,180,.20) 0 2px, transparent 3px);
      filter: blur(.2px);
      animation: floaty 8s ease-in-out infinite alternate;
    }
    @keyframes floaty { from{transform:translateY(-8px)} to{transform:translateY(8px)} }
    .card{
      width:min(720px, 92vw);
      background: rgba(16,26,46,.72);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      border-radius: 22px;
      padding: 36px;
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      position:relative;
      min-height: clamp(220px, 40vh, 300px);
    }
    .title{
      font-size: clamp(24px, 2.8vw, 30px);
      margin:0 0 8px;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0 0 22px;
      color:var(--muted);
      line-height:1.4;
      font-size: 15px;
    }
    .row{
      display: grid;
      grid-template-columns: max-content minmax(0, 1fr); /* âœ… important */
      gap: 12px;
      align-items: start;   /* top-align both columns */
      margin-top: 10px;
    }

    .yesZone,
    .noZone{
      display: flex;
      align-items: flex-start;
      padding: 10px;
    }

    .noZone{
      position: relative;
      min-height: 90px;
      border-radius: 14px;
      overflow: hidden;
    }

    button{
      border:none;
      border-radius: 14px;
      padding: 12px 16px;
      font-weight: 700;
      cursor:pointer;
      transition: transform .15s ease, filter .15s ease;
      user-select:none;
      touch-action: manipulation;
    }
    button:active{ transform: scale(.98) }
    .yes{
      background: linear-gradient(135deg, #ff8a00, #ff3d00);
      color:white;
      box-shadow: 0 10px 30px rgba(255, 120, 0, .35);
    }

    .yes:hover{
      filter: brightness(1.08);
    }


    .no{
      background: rgba(255,255,255,.08);
      color: rgba(255,255,255,.92);
      border: 1px solid rgba(255,255,255,.16);
      position:relative;
      white-space: nowrap;
      min-width: 110px;
      transition: all .15s ease;
    }

    /* UPDATED: "blocked" is now ONLY a visual hint (does not block events) */
    .no.blocked{
      opacity: 0.95;
      cursor: default;
    }


    .yes:disabled,
    .no:disabled{
      opacity: 0.6;
      cursor: not-allowed;
    }
    .result{
      margin-top:18px;
      padding: 14px 14px;
      border-radius: 16px;
      background: rgba(255,255,255,.08);
      border: 1px dashed rgba(255,255,255,.18);
      display:none;
    }
    .result.show{ display:block }
    .result h2{ margin:0 0 6px; font-size:20px }
    .result p{ margin:0; color:rgba(255,255,255,.78) }
    canvas#confetti{
      position:fixed; inset:0; pointer-events:none; z-index:10;
    }
    .tiny{
      font-size: 12px;
      color: rgba(255,255,255,.55);
      margin-top: 10px;
    }
    a{ color:#ffd1e5 }

    /* Mobile: allow NO button text to wrap */
    @media (max-width: 430px) {
      .no{
        white-space: normal;
        width: 100%;
        max-width: 100%;
        min-width: 0;
        padding: 10px 12px;
        line-height: 1.2;
        text-align: center;
      }

      .noZone{
        width: 100%;
        min-height: 140px;
        overflow: visible;   /* âœ… stop clipping wrapped text */
      }

    }

  </style>
</head>
<body>
<div class="hearts"></div>
<canvas id="confetti"></canvas>

<main class="card" id="card">
  <h2 class="title" id="question">Will you be my Valentine, <span id="name">love</span>?</h2>
  <p class="subtitle" id="sub">No pressure ðŸ˜„ Just a tiny question with huge romantic consequences.</p>

  <div class="row" id="buttonZone">
    <div class="yesZone">
      <button class="yes" id="yesBtn">Yes ðŸ’–</button>
    </div>

    <div class="noZone" id="noZone">
      <button class="no" id="noBtn">No ðŸ™ˆ</button>
    </div>
  </div>

  <div class="result" id="result">
    <h2 id="yayTitle">YAY!! ðŸŽ‰ðŸ’˜</h2>
    <p id="yayMsg">Date locked in. Iâ€™m smiling already ðŸ˜Œ</p>
    <div class="tiny" id="tinyLine"></div>
  </div>
</main>

<script>
  // --- Personalization via URL params ---
  const params = new URLSearchParams(location.search);
  const personName = params.get("name");
  const fromName = params.get("from");
  const customQ = params.get("q");
  const customYes = params.get("yes");

  if (personName) document.getElementById("name").textContent = personName;
  if (customQ) document.getElementById("question").innerHTML = customQ;
  if (customYes) document.getElementById("yayMsg").textContent = customYes;

  const tiny = document.getElementById("tinyLine");
  if (fromName) tiny.innerHTML = `â€” from <b>${fromName}</b>`;

  // --- Elements ---
  const noBtn = document.getElementById("noBtn");
  const noZone = document.getElementById("noZone");
  const yesBtn = document.getElementById("yesBtn");

  const result = document.getElementById("result");
  const yayTitle = document.getElementById("yayTitle");
  const yayMsg = document.getElementById("yayMsg");

  // --- State ---
  let dodgeLevel = 0;
  const maxDodge = 8;
  let lastNoTextIndex = -1;

  let yesCount = 0;        // total YES clicks (never reset)
  let dodgeEnabled = true; // controls NO dodging

  // Start in dodge mode: NO "looks" not-ready, but still receives hover/touch so dodging works
  noBtn.classList.add("blocked");

  // --- NO click limit + messages ---
  const NO_CLICK_LIMIT = 5;
  let noClickCount = 0;
  const noClickMessages = [
    "Respawning in 3 2 1...",
    "Is this supposed to be funny? ðŸ˜’",
    "Youâ€™re making this way harder than it needs to beâ€¦ thatâ€™s what she said.",
    "Oyi... Kelabo...",
    "Eirom Korish na! ABAR..."
  ];

  // --- Helpers ---
  function resetNoButtonPosition() {
    noBtn.style.position = "";
    noBtn.style.left = "";
    noBtn.style.top = "";
  }

  function resetDodgeState() {
    dodgeLevel = 0;
    lastNoTextIndex = -1;
  }

  // reset visuals only; does NOT touch yesCount/noClickCount
  function resetUI({ enableDodge = true, hideResult = true } = {}) {
    if (hideResult) result.classList.remove("show");
    resetNoButtonPosition();
    resetDodgeState();
    dodgeEnabled = enableDodge;

    if (enableDodge) {
      noBtn.disabled = false;
      noBtn.classList.add("blocked"); // visual "not yet"
      noBtn.textContent = "No ðŸ™ˆ";
    } else {
      noBtn.classList.remove("blocked");
    }
  }

  function lockEverythingFinal() {
    dodgeEnabled = false;

    resetNoButtonPosition();

    noBtn.textContent = "No ðŸ™ˆ";
    noBtn.classList.remove("blocked");

    yesBtn.disabled = true;
    noBtn.disabled = true;

    result.classList.add("show");
    yayTitle.textContent = "That's all the chances you are going to get Paglu...ðŸ’˜";
    yayMsg.textContent = "YOU ARE MINE!!!! ðŸ¥° ";
  }

  // YES is temporarily disabled while NO message is shown.
  // Guard prevents it from re-enabling after final lock.
  function temporarilyDisableYes(duration = 4000) {
    yesBtn.disabled = true;
    setTimeout(() => {
      if (!noBtn.disabled) yesBtn.disabled = false;
    }, duration);
  }

  function moveNoButton() {
    const zoneRect = noZone.getBoundingClientRect();
    const btnRect = noBtn.getBoundingClientRect();
    const padding = 6;

    const minX = padding;
    const minY = padding;
    const maxX = Math.max(minX, zoneRect.width - btnRect.width - padding);
    const maxY = Math.max(minY, zoneRect.height - btnRect.height - padding);

    const x = Math.random() * (maxX - minX) + minX;
    const y = Math.random() * (maxY - minY) + minY;

    noBtn.style.position = "absolute";
    noBtn.style.left = x + "px";
    noBtn.style.top = y + "px";
  }

  function updateNoTextForDodge() {
    const texts = [
      "No ðŸ™ˆ",
      "are you sure? ðŸ˜³",
      "hmmâ€¦ try again ðŸ˜Œ",
      "Amai chere jaash Naaaa! ðŸ¥º",
      "Agreement!! ðŸ“ƒ"
    ];

    if (texts.length === 1) {
      noBtn.textContent = texts[0];
      return;
    }

    let idx;
    do {
      idx = Math.floor(Math.random() * texts.length);
    } while (idx === lastNoTextIndex);

    lastNoTextIndex = idx;
    noBtn.textContent = texts[idx];
  }

  // --- Dodge behavior ---
  function dodge() {
    if (!dodgeEnabled) return;
    if (dodgeLevel >= maxDodge) return;

    dodgeLevel++;
    updateNoTextForDodge();
    moveNoButton();

    // At the moment we reach the limit: visually become "ready"
    if (dodgeLevel === maxDodge) {
      noBtn.classList.remove("blocked");
    }
  }

  noBtn.addEventListener("mouseenter", dodge);
  noBtn.addEventListener("touchstart", dodge, { passive: true });

  // --- YES behavior ---
  yesBtn.addEventListener("click", () => showResult(true));

  function showResult(isYes) {
    result.classList.add("show");
    if (!isYes) return;

    yesCount++;

    // 1st YES: bring NO back + stop dodging + set tease label
    if (yesCount === 1) {
      resetNoButtonPosition();
      resetDodgeState();
      dodgeEnabled = false;

      noBtn.classList.remove("blocked");
      noBtn.disabled = false;

      yayTitle.textContent = "YAY!! ðŸŽ‰ðŸ’˜";
      yayMsg.textContent = "You've chosen wisely ðŸ˜";
      noBtn.textContent = "Want me to tease you again??? ðŸ˜˜";

      popConfetti();
      return;
    }

    // 2nd YES+: disable NO backsies
    if (yesCount >= 2) {
      resetNoButtonPosition();
      resetDodgeState();
      dodgeEnabled = false;

      noBtn.classList.remove("blocked");

      yayTitle.textContent = "You're locked in ðŸ˜ðŸ’–";
      yayMsg.textContent = "Can't escape now... ðŸƒâ€âž¡ï¸ðŸƒâ€âž¡ï¸ðŸƒâ€âž¡ï¸";
      noBtn.textContent = "NO BACKSIES";
      noBtn.disabled = true;

      popConfetti();
      return;
    }
  }

  // --- NO click behavior ---
  noBtn.addEventListener("click", () => {
    if (noBtn.disabled || yesBtn.disabled) return;

    // âœ… IMPORTANT: During dodge phase, ignore clicks until max dodges
    if (dodgeEnabled && dodgeLevel < maxDodge) return;

    temporarilyDisableYes(4000);

    // Tease mode click (after 1st YES) - do not count
    if (
      yesCount === 1 &&
      !dodgeEnabled &&
      noBtn.textContent.includes("tease you again")
    ) {
      result.classList.add("show");
      yayTitle.textContent = "ðŸ˜ˆ";
      yayMsg.textContent = "Oh! So Naughty!! Starting in 3 2 1...";

      setTimeout(() => {
        resetUI({ enableDodge: true, hideResult: true });
      }, 4000);

      return;
    }

    // Count this NO click
    noClickCount++;

    // Show unique message for this NO click
    const msgIndex = Math.min(noClickCount - 1, noClickMessages.length - 1);
    result.classList.add("show");
    yayTitle.textContent = "ðŸ˜";
    yayMsg.textContent = noClickMessages[msgIndex];

    // Limit reached: disable both and show final message (no reset)
    if (noClickCount >= NO_CLICK_LIMIT) {
      lockEverythingFinal();
      return;
    }

    // Otherwise reset after 4 seconds and allow dodging again
    setTimeout(() => {
      resetUI({ enableDodge: true, hideResult: true });
    }, 4000);
  });

  // --- Minimal confetti (no libraries) ---
  const canvas = document.getElementById("confetti");
  const ctx = canvas.getContext("2d");
  let confetti = [];

  function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
  }
  addEventListener("resize", resize);
  resize();

  function popConfetti() {
    const pieces = 180;
    confetti = Array.from({ length: pieces }, () => ({
      x: Math.random() * canvas.width,
      y: -20 - Math.random() * canvas.height * 0.2,
      r: 4 + Math.random() * 5,
      vx: -2 + Math.random() * 4,
      vy: 2 + Math.random() * 4,
      rot: Math.random() * Math.PI,
      vr: -0.15 + Math.random() * 0.3,
      life: 120 + Math.random() * 60
    }));
    requestAnimationFrame(tick);
  }

  function tick() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    confetti.forEach((p) => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.03;
      p.rot += p.vr;
      p.life -= 1;

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.globalAlpha = Math.max(0, Math.min(1, p.life / 180));

      // Sunset color palette
      const sunsetHues = [15, 22, 28, 35, 350];
      const hue = sunsetHues[Math.floor(Math.random() * sunsetHues.length)];
      const lightness = 60 + Math.random() * 15;

      ctx.fillStyle = `hsl(${hue}, 95%, ${lightness}%)`;


      ctx.fillRect(-p.r / 2, -p.r / 2, p.r, p.r);
      ctx.restore();
    });

    confetti = confetti.filter((p) => p.life > 0 && p.y < canvas.height + 40);
    if (confetti.length) requestAnimationFrame(tick);
  }
</script>
</body>
</html>
